# Game Time
* Students: Daniella Carey & Eric Jungbluth
* Evaluator: Cody Sehl
* Repo: https://github.com/danielafcarey/frogger

### Github issues assigned and resolved

- Get rid of magic numbers
- Test constructor and constructor defaults behavior in single test
- Don't test inheritance

### Functional Expectations

- Game works as it should!

Score: 3

* 3 - Application is fully playable without crashes or bugs

### User Interface

- UI is great

Score: 4

* 4 - The application is pleasant, logical, and easy to use. There are no holes in functionality and the application stands on its own to be used by the instructor _without_ guidance from the developer.

### Testing

- Don't test inheritance
- Good use of action -> result in test names
- Opinion: Can test default constructor values in one test

Score: 3

* 3 - Project has a running test suite that tests multiple levels but fails to cover some features. All functionality is covered by tests. The application makes some use of integration testing. ESLint shows < 5 complaints.

### JavaScript Style

- Consider assigning confusing expressions in if statements to their own variables
- Refactor magic numbers in Obstacle.js

Score: 3-4

* 4 - Application has exceptionally well-factored code with little or no duplication. SRP (single responsibility principle) and DRY (don't repeat yourself) principles are utilized. There are _zero_ instances where an instructor would recommend taking a different approach.
* 3 - Application is thoughtfully put together with some duplication and no major bugs. Developer can speak to choices made in the code and knows what every line of code is doing.

### Application Organization

- Great separation of different collision detection functions
- Great knowledge of separation and what component should have what knowledge

Score: 3-4

* 4 - Application is organized into classes (and correctly uses inheritance) and there are no instances where instructor would suggest moving logic or data to another class. The business-logic code driving functionality is cleanly separated from rendering, view-related code.
* 3 - Application is organized into classes (and correctly uses inheritance) with some misplaced logic and no major bugs. Business-logic code is mostly separated from view-related code. Developer can speak to choices made in the code and knows what each line of code is doing.

### Workflow

- Good job making lots of commits, small commits, small PRs
- Great use of Asana

Score: 3-4

* 4 - The developer/team effectively uses Git branches and many small, atomic commits that document the evolution of their application with descriptive commit messages. The team displays good pairing practices (driver-navigator, dividing up work, etc) and utilizes some sort of planning tool (GitHub issues, Waffle, Trello, etc). The team develops a clear MVP (minimum viable product) and conducts a DTR (define the relationship). Both members contribute meaningfully to the application.
* 3 - The developer/team makes a series of small, atomic commits that document the evolution of their application. There are no formatting issues in the code base. The team conducts a DTR (define the relationship) and utilizes a planning tool and pairing practices. Both members contribute meaningfully to the application.
