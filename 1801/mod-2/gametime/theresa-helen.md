# Game Time
* Students: Helen Dechat & Theresa Marquis
* Evaluator: Cody Sehl
* Repo: https://github.com/tmcjunkinmarquis/game-time-2


### Functional Expectations

✓ It works!

Score: 3

* 3 - Application is fully playable without crashes or bugs

### User Interface

✓ Work on turning the alerts into actual game screens

Score: 3

* 3 - The application has many strong pages/interactions, but a few holes in lesser-used functionality.

### Testing

✓ Don't need to test inheritance
✓ Make it clear what action causes what result in the test names
✓ Don't need test to say whether or not functions exist
- Stretch goal: Add integration tests - write a test for the scenario "Can the frog with the game?"

Score: 3

* 3 - Project has a running test suite that tests multiple levels but fails to cover some features. All functionality is covered by tests. The application makes some use of integration testing. ESLint shows < 5 complaints.

### JavaScript Style

✓ Reduce usages of magic numbers. See game.js -> checkFrogDrowns function
✓ Consider naming conditionals used in collision detection code in Log.js

Score: 3

* 3 - Application is thoughtfully put together with some duplication and no major bugs. Developer can speak to choices made in the code and knows what every line of code is doing.

### Application Organization

✓ Consider moving conditionals in Log.js checkForFrog into their own, more understandable variables
- Stretch goal: move context and DOM manipulation out of game.js and into index. Write tests for gameLoop()

Score: 3

* 3 - Application is organized into classes (and correctly uses inheritance) with some misplaced logic and no major bugs. Business-logic code is mostly separated from view-related code. Developer can speak to choices made in the code and knows what each line of code is doing.

### Workflow

✓ Not as much Driver/Navigator, so more opportunity to learn about git and distributed workflows
✓ Great workflow!
✓ Excellent use of github issues, branches, and pull requests.

Score: 4

* 4 - The developer/team effectively uses Git branches and many small, atomic commits that document the evolution of their application with descriptive commit messages. The team displays good pairing practices (driver-navigator, dividing up work, etc) and utilizes some sort of planning tool (GitHub issues, Waffle, Trello, etc). The team develops a clear MVP (minimum viable product) and conducts a DTR (define the relationship). Both members contribute meaningfully to the application.
